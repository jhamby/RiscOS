/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * Copyright(c) 1994 Acorn Computers Ltd., Cambridge, England
 */
#include <string.h>

#include "smb_riscos.h"
#include "swis.h"

#include "sys/socket.h"
#include "sys/time.h"

#include "net/if.h"
#include "net/if_arp.h"

#include "netinet/in.h"
#include "netinet/if_ether.h"

struct mbctl MBCTL_NAME =
{
	0,				/* opaque */
	sizeof(struct mbctl),		/* mbcsize */
	MBUF_MANAGER_VERSION,		/* mbcvers */
	0ul,				/* flags */
	MINCONTIG,			/* advminubs */
	ETHERMTU,			/* advmaxubs */
	MINCONTIG,			/* mincontig */
	0ul,				/* spare1 */
	/*
	 * Rest of the structure gets initialised
	 * to zeroes due to the trailing comma
	 */
};

/**********************************************************************/

_kernel_oserror *mb_entryinit(void)
{
    return _swix(Mbuf_OpenSession, _IN(0), &MBCTL_NAME);
}

/**********************************************************************/

#if 0
/*
 * mb_present - check whether the mbuf manager is present or not,
 * using the Mbuf_Control SWI to do so.	 returns 1 if manager
 * present, else 0.
 */
int mb_present(void)
{
    /*
     * the control version SWI should *always*
     * succeed if the mbuf manager is loaded.
     */
    return mbufcontrol_version(0) == NULL;
}
#endif

/**********************************************************************/

_kernel_oserror *mb_close_session(void)
{
    return _swix(Mbuf_CloseSession, _IN(0), &MBCTL_NAME);
}

/**********************************************************************/

/*
 * Copy data from a buffer back into the indicated mbuf chain,
 * starting "off" bytes from the beginning, extending the mbuf
 * chain if necessary.
 */
void m_copyback(struct mbuf *m0, register int off, register int len, caddr_t cp)
{
	register int mlen;
	register struct mbuf *m = m0, *n;
	int totlen = 0;

	if (m0 == 0)
		return;
	while (off > (mlen = m->m_len)) {
		off -= mlen;
		totlen += mlen;
		if (m->m_next == 0) {
			n = m_alloc_c(MINCONTIG, NULL);
			if (n == 0)
				goto out;
			n->m_type = m->m_type;
			n->m_len = min(MINCONTIG, len + off);
			m->m_next = n;
		}
		m = m->m_next;
	}
	while (len > 0) {
		mlen = min (m->m_len - off, len);
		memcpy(off + mtod(m, caddr_t), cp, (unsigned)mlen);
		cp += mlen;
		len -= mlen;
		mlen += off;
		off = 0;
		totlen += mlen;
		if (len == 0)
			break;
		if (m->m_next == 0) {
			n = m_alloc_s(MINCONTIG, NULL);
			if (n == 0)
				break;
			n->m_type = m->m_type;
			n->m_len = min(MINCONTIG, len);
			m->m_next = n;
		}
		m = m->m_next;
	}
out:
	if (((m = m0)->m_flags & M_PKTHDR) && (m->m_pkthdr.len < totlen))
		m->m_pkthdr.len = totlen;
}

/* Modified copy of function from Networking/AUN/Internet/kern/c/uipc_mbuf. */

/*
 * Make a copy of an mbuf chain starting "off0" bytes from the beginning,
 * continuing for "len" bytes.  If len is M_COPYALL, copy to end of mbuf.
 * The wait parameter is a choice of M_WAIT/M_DONTWAIT from caller.
 */
struct mbuf *
m_copym(struct mbuf *m, size_t off0, size_t len, int wait)
{
    (void) wait;  /* ignored */

    struct mbuf *n;
    int copyhdr = 0;

    if (off0 == 0 && m->m_flags & M_PKTHDR)
        copyhdr = 1;

    n = m_copy_p(m, off0, len);
#if 0
    if (n == 0) {
        m_reclaim();
        n = m_copy_p(m, off0, len);
    }
#endif
    if (n == 0)
        return (0);

    if (copyhdr) {
        M_COPY_PKTHDR(n, m);
        if (len == M_COPYALL)
            n->m_pkthdr.len -= off0;
        else
            n->m_pkthdr.len = len;
    }
    return (n);
}

/* Helper functions from xnu bsd/kern/uipc_mbuf.c */

/*
 * Lesser-used path for M_PREPEND: allocate new mbuf to prepend to chain,
 * copy junk along.  Does not adjust packet header length.
 */
static inline struct mbuf *
m_prepend(struct mbuf *m, int len, int how)
{
    struct mbuf *mn;

    if ( mbuf_get( how, m->m_type, &mn ) ) {
        m_freem(m);
        return (NULL);
    }
    if (m->m_flags & M_PKTHDR) {
        M_COPY_PKTHDR(mn, m);
        m->m_flags &= ~M_PKTHDR;
    }
    mn->m_next = m;
    m = mn;
#if 0
    if (len < MHLEN)
        MH_ALIGN(m, len);
#endif
    m->m_len = len;
    return (m);
}

/*
 * Replacement for old M_PREPEND macro: allocate new mbuf to prepend to
 * chain, copy junk along, and adjust length.
 */
struct mbuf *
m_prepend_2(struct mbuf *m, int len, int how)
{
    if ( mbuf_leadingspace(m) >= len ) {
        m->m_off -= len;
        m->m_len += len;
    } else {
        m = m_prepend(m, len, how);
    }
    if ((m) && (m->m_flags & M_PKTHDR))
        m->m_pkthdr.len += len;
    return (m);
}
