/*
 * Copyright (c) 2012, RISC OS Open Ltd
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of RISC OS Open Ltd nor the names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/* Original version copied from HWSupport/VCHIQ/c/vchiq_riscos in BCM2835. */

#include "kernel.h"
#include "swis.h"
#include <errno.h>
#include <stdlib.h>

#include "AsmUtils/irqs.h"
#include "DebugLib/DebugLib.h"
#include "Global/HALEntries.h"
#include "Interface/RTSupport.h"

/* Implementation of some thread functions needed by SMBX client. */

/* static const int dummy_pollword_1 = 1; */
static const int dummy_pollword_0 = 0;

/* Threads */

#define THREAD_STACK_SIZE 16384

static void thread_wrapper(struct task_struct *t)
{
    /* Initialise t->rt_handle */
    _swix(RT_ReadInfo, _IN(0) | _OUT(0), RTReadInfo_Handle, &t->rt_handle);
    if (!t->stop)
        t->retval = t->thread_function(t->data);
    t->stopped = 1;
    _swix(RT_Deregister, _INR(0, 1), 0, t->rt_handle);
}

struct task_struct *kthread_create(int (*func)(void *), void *param,
                                   const char *name)
{
    (void)name;

    struct task_struct *thread = malloc(sizeof(struct task_struct));
    if (!thread)
    {
        return 0;
    }
    memset(thread, 0, sizeof(struct task_struct));
    _kernel_stack_chunk *stack = malloc(THREAD_STACK_SIZE);
    if (!stack)
    {
        free(thread);
        return 0;
    }
    thread->stop = false;
    thread->retval = NULL;
    thread->stack = stack;
    stack->sc_mark = 0xF60690FF;
    stack->sc_size = THREAD_STACK_SIZE;
    memcpy(stack + 1, _kernel_current_stack_chunk() + 1, 28);

    thread->thread_function = func;
    thread->data = param;

    /* We create one I/O thread per SMB VC, running at a low priority. */
    _kernel_oserror *e =
        _swix(RT_Register, _INR(0, 7) | _OUT(0), 0, thread_wrapper, thread,
              our_private_word, &thread->wakeup, ((int)stack) + 560,
              ((int)stack) + THREAD_STACK_SIZE, "LanManIO:32",
              &thread->rt_handle);
    if (e)
    {
        free(stack);
        free(thread);
        return 0;
    }
    return thread;
}

void wake_up_process(struct task_struct *t) { t->wakeup = 1; }

void msleep(uint32_t ms)
{
    uint32_t csecs = (ms + 9) / 10;
    _swix(RT_TimedYield, _INR(1, 2), &dummy_pollword_0,
          csecs + _swi(OS_ReadMonotonicTime, _RETURN(0)));
}
